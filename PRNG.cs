using System;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Lidgren.Core
{
	/// <summary>
	/// Random numbers generated by XorShift64*
	/// </summary>
	public static class PRNG
	{
		/// <summary>
		/// This is not thread local data by design because that would be slower in the general case
		/// Whenever concurrency might occur; use the ref state overloads with a local variable instead
		/// </summary>
		private static ulong s_state = RandomSeed.GetUInt64();

		/// <summary>
		/// Returns random value between 0 and UInt64.MaxValue using XorShift64*
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static ulong NextUInt64(ref ulong state)
		{
			unchecked
			{
				var x = state;
				x ^= x >> 12;
				x ^= x << 25;
				x ^= x >> 27;
				state = x;
				return x * 0x2545F4914F6CDD1D;
			}
		}

		/// <summary>
		/// Returns random value between 0 and UInt64.MaxValue using XorShift64*
		/// </summary>
		public static ulong NextUInt64()
		{
			unchecked
			{
				var x = s_state;
				x ^= x >> 12;
				x ^= x << 25;
				x ^= x >> 27;
				s_state = x;
				return x * 0x2545F4914F6CDD1D;
			}
		}

		/// <summary>
		/// Returns random value between 0 and UInt32.MaxValue
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static uint NextUInt32(ref ulong state)
		{
			unchecked
			{
				var x = state;
				x ^= x >> 12;
				x ^= x << 25;
				x ^= x >> 27;
				state = x;
				return (uint)((x * 0x2545F4914F6CDD1D) >> 32); // use upper bits
			}
		}

		/// <summary>
		/// Returns random value between 0 and UInt32.MaxValue
		/// </summary>
		public static uint NextUInt32()
		{
			unchecked
			{
				var x = s_state;
				x ^= x >> 12;
				x ^= x << 25;
				x ^= x >> 27;
				s_state = x;
				return (uint)((x * 0x2545F4914F6CDD1D) >> 32); // use upper bits
			}
		}

		/// <summary>
		/// Returns true or false randomly
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool NextBool(ref ulong state)
		{
			unchecked
			{
				var x = state;
				x ^= x >> 12;
				x ^= x << 25;
				x ^= x >> 27;
				state = x;
				return (x * 0x2545F4914F6CDD1D) > 0x7FFFFFFFFFFFFFFFul;
			}
		}

		/// <summary>
		/// Returns true or false randomly
		/// </summary>
		public static bool NextBool()
		{
			unchecked
			{
				var x = s_state;
				x ^= x >> 12;
				x ^= x << 25;
				x ^= x >> 27;
				s_state = x;
				return (x * 0x2545F4914F6CDD1D) > 0x7FFFFFFFFFFFFFFFul;
			}
		}

		private static ulong s_bools = 0;
		private static int s_remainingBools = 0;

		/// <summary>
		/// Returns true or false randomly
		/// </summary>
		public static bool NextBoolAlt()
		{
			if (s_remainingBools == 0)
			{
				s_remainingBools = 64;
				s_bools = NextUInt64();
			}

			var retval = (s_bools & 1) == 1;
			s_bools >>= 1;
			s_remainingBools--;
			return retval;
		}

		/// <summary>
		/// Fills buffer slice with random numbers
		/// </summary>
		public static void NextBytes(byte[] buffer, int offset, int length)
		{
			NextBytes(ref s_state, new Span<byte>(buffer, offset, length));
		}

		public static void NextBytes(byte[] buffer)
		{
			NextBytes(buffer, 0, buffer.Length);
		}

		public static void NextBytes(Span<byte> buffer)
		{
			NextBytes(ref s_state, buffer);
		}

		/// <summary>
		/// Fills buffer slice with random numbers
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void NextBytes(ref ulong state, Span<byte> bytes)
		{
			unchecked
			{
				Span<ulong> ulongs = MemoryMarshal.Cast<byte, ulong>(bytes);

				int full = bytes.Length / 8;
				for (int i = 0; i < full; i++)
				{
					var x = state;
					x ^= x >> 12;
					x ^= x << 25;
					x ^= x >> 27;
					state = x;
					ulongs[i] = x * 0x2545F4914F6CDD1D;
				}

				int offset = full * 8;
				while (offset < bytes.Length)
					bytes[offset++] = (byte)NextUInt64(ref state);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int Next(ref ulong state, int minValue, int maxValue)
		{
			CoreException.Assert(maxValue > minValue);
			unchecked
			{
				uint span = (uint)(maxValue - minValue);
				uint usableRange = uint.MaxValue - (uint.MaxValue % span);
				uint rnd;
				do
				{
					rnd = NextUInt32(ref state);
				} while (rnd > usableRange);

				var retval = (int)(minValue + (rnd % span));
				CoreException.Assert(retval >= minValue && retval < maxValue);
				return retval;
			}
		}

		/// <summary>
		/// Returns a random value larger or equal to minValue and less than maxValue
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int Next(int minValue, int maxValue)
		{
			return Next(ref s_state, minValue, maxValue);
		}

		/// <summary>
		/// Returns random value larger or equal to 0.0 and less than 1.0
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static double NextDouble(ref ulong state)
		{
			DoubleULongUnion union;
			union.DoubleValue = 0;
			union.ULongValue = (NextUInt64(ref state) & 0xFFFFFFFFFFFFFUL) | 0x3FF0000000000000UL;
			double zeroToOne = union.DoubleValue - 1.0;
			CoreException.Assert(zeroToOne >= 0.0f && zeroToOne < 1.0);
			return zeroToOne;
		}

		/// <summary>
		/// Returns random value larger or equal to 0.0 and less than 1.0
		/// </summary>
		public static double NextDouble()
		{
			return NextDouble(ref s_state);
		}

		/// <summary>
		/// Returns random value larger or equal to minValue and less than maxValue
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static double NextDouble(ref ulong state, double minValue, double maxValue)
		{
			CoreException.Assert(maxValue > minValue);

			DoubleULongUnion union;
			union.DoubleValue = 0;
			union.ULongValue = (NextUInt64(ref state) & 0xFFFFFFFFFFFFFUL) | 0x3FF0000000000000UL;
			double zeroToOne = union.DoubleValue - 1.0;
			double retval = minValue + ((maxValue - minValue) * zeroToOne);
			CoreException.Assert(retval >= minValue && retval < maxValue);
			return retval;
		}

		/// <summary>
		/// Returns random value larger or equal to minValue and less than maxValue
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static double NextDouble(double minValue, double maxValue)
		{
			return NextDouble(ref s_state, minValue, maxValue);
		}

		/// <summary>
		/// Returns random value larger or equal to 0.0f and less than 1.0f
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static float NextFloat(ref ulong state)
		{
			return (float)NextDouble(ref state);
		}

		/// <summary>
		/// Returns random value larger or equal to 0.0f and less than 1.0f
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static float NextFloat()
		{
			return NextFloat(ref s_state);
		}

		/// <summary>
		/// Returns random value larger or equal to minValue and less than maxValue
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static float NextFloat(ref ulong state, float minValue, float maxValue)
		{
			return (float)NextDouble(ref state, minValue, maxValue);
		}

		/// <summary>
		/// Returns random value larger or equal to minValue and less than maxValue
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static float NextFloat(float minValue, float maxValue)
		{
			return (float)NextDouble(ref s_state, minValue, maxValue);
		}

		/// <summary>
		/// Returns random point on circle, unit length
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void NextUnitCircle(out float x, out float y)
		{
			NextUnitCircle(ref s_state, out x, out y);
		}

		/// <summary>
		/// Returns random point on circle, unit length
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void NextUnitCircle(ref ulong state, out float x, out float y)
		{
			var azimuth = NextFloat(0, MathF.PI * 2.0f);
			x = MathF.Cos(azimuth);
			y = MathF.Sin(azimuth);
		}

		/// <summary>
		/// Returns random point on sphere, unit length
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void NextUnitSphere(out float x, out float y, out float z)
		{
			NextUnitSphere(ref s_state, out x, out y, out z);
		}

		/// <summary>
		/// Returns random point on sphere, unit length
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static Vector3 NextUnitSphere()
		{
			Vector3 retval;
			NextUnitSphere(ref s_state, out retval.X, out retval.Y, out retval.Z);
			return retval;
		}

		/// <summary>
		/// Returns random point on sphere, unit length
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void NextUnitSphere(ref ulong state, out float x, out float y, out float z)
		{
			float dz = NextFloat(ref state) * 2.0f - 1.0f;
			float m = MathF.Sqrt(1.0f - dz * dz);
			float azimuth = ((NextFloat(ref state) * 2.0f - 1.0f) * 0.5f + 0.5f) * 2.0f * MathF.PI;
			x = MathF.Cos(azimuth) * m;
			y = MathF.Sin(azimuth) * m;
			z = dz;
		}

		/// <summary>
		/// Returns a random rotation around an axis
		/// </summary>
		public static Quaternion NextAxisRotation(in Vector3 axis)
		{
			return Quaternion.CreateFromAxisAngle(axis, PRNG.NextFloat(0, MathF.PI * 2.0f));
		}

		/// <summary>
		/// Returns a random rotation around a random axis
		/// </summary>
		public static Quaternion NextRotation()
		{
			Vector3 axis;
			NextUnitSphere(out axis.X, out axis.Y, out axis.Z);
			return Quaternion.CreateFromAxisAngle(axis, PRNG.NextFloat(0, MathF.PI * 2.0f));
		}

		/// <summary>
		/// Returns values from a rough bell shape skewed to have its peak at 'mode'  (min <= x < max)
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static float NextPseudoGaussian(float min, float max, float mode)
		{
			return NextPseudoGaussian(ref s_state, min, max, mode);
		}

		/// <summary>
		/// Returns values from a rough bell shape skewed to have its peak at 'mode'  (min <= x < max)
		/// </summary>
		public static float NextPseudoGaussian(ref ulong state, float min, float max, float mode)
		{
			float nrmValue;
			nrmValue = (NextFloat(ref state) + NextFloat(ref state) + NextFloat(ref state)) * 0.666666666f;
			if (nrmValue > 1.0f)
				nrmValue = 1.0f - (nrmValue - 1.0f);

			var modep = (mode - min) / (max - min);
			if (NextDouble() < modep)
			{
				// lower half
				var span = mode - min;
				return min + (span * nrmValue);
			}
			else
			{
				// upper half
				var span = max - mode;
				return mode + (span * (1.0f - nrmValue));
			}
		}

		/// <summary>
		/// Returns values from a rough bell shape skewed to have its peak at 'mode'  (min <= x < max)
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static double NextPseudoGaussian(double min, double max, double mode)
		{
			return NextPseudoGaussian(ref s_state, min, max, mode);
		}

		/// <summary>
		/// Returns values from a rough bell shape skewed to have its peak at 'mode'  (min <= x < max)
		/// </summary>
		public static double NextPseudoGaussian(ref ulong state, double min, double max, double mode)
		{
			double nrmValue;
			nrmValue = (NextDouble(ref state) + NextDouble(ref state) + NextDouble(ref state)) * 0.666666666f;
			if (nrmValue > 1.0)
				nrmValue = 1.0 - (nrmValue - 1.0);

			var modep = (mode - min) / (max - min);
			if (NextDouble() < modep)
			{
				// lower half
				var span = mode - min;
				return min + (span * nrmValue);
			}
			else
			{
				// upper half
				var span = max - mode;
				return mode + (span * (1.0 - nrmValue));
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void Shuffle<T>(Span<T> list)
		{
			Shuffle(list, ref s_state);
		}

		/// <summary>
		/// Randomly shuffle the elements (Fisher-Yates)
		/// </summary>
		public static void Shuffle<T>(in Span<T> list, ref ulong state)
		{
			for (int i = 0; i < list.Length - 1; i++)
			{
				int j = Next(i, list.Length);
				T tmp = list[i];
				list[i] = list[j];
				list[j] = tmp;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void Fill<T>(Span<T> span) where T : struct
		{
			var bytes = MemoryMarshal.AsBytes<T>(span);
			NextBytes(bytes);
		}
	}
}
