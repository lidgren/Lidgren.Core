#nullable enable
//#define SPLITMIX64
using System;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Lidgren.Core
{
	/// <summary>
	/// Random numbers generated by XorShift64*
	/// </summary>
	public static class PRNG
	{
		private const ulong c_star = 0x2545F4914F6CDD1Dul; // 2685821657736338717

		/// <summary>
		/// This is not thread local data by design because that would be slower in the general case
		/// Whenever concurrency might occur; use the ref state overloads with a local variable instead
		/// </summary>
		private static ulong s_state = RandomSeed.GetUInt64();

		/// <summary>
		/// Returns random value between 0 and UInt64.MaxValue using XorShift64*
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static ulong NextUInt64(ref ulong state)
		{
			unchecked
			{
#if SPLITMIX64
				state += 0x9e3779b97f4a7c15ul;
				ulong z = state;
				z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
				z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
				return z ^ (z >> 31);
#else
				var x = state;
				x ^= x >> 12;
				x ^= x << 25;
				x ^= x >> 27;
				state = x;
				return x * c_star;
#endif
			}
		}


		/// <summary>
		/// Returns random value between 0 and UInt64.MaxValue using XorShift64*
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static ulong NextUInt64()
		{
			return NextUInt64(ref s_state);
		}

		/// <summary>
		/// Returns random value between 0 and UInt32.MaxValue
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static uint NextUInt32(ref ulong state)
		{
			var value = NextUInt64(ref state);
			return (uint)(value >> 32); // use upper bits
		}

		/// <summary>
		/// Returns random value between 0 and UInt32.MaxValue
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static uint NextUInt32()
		{
			var value = NextUInt64(ref s_state);
			return (uint)(value >> 32); // use upper bits
		}

		/// <summary>
		/// Returns true or false randomly
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool NextBool(ref ulong state)
		{
			BoolUIntUnion union;
			union.BoolValue = false;
			union.UIntValue = (NextUInt32(ref state) >> 16) & 1u; // don't trust the lower bits
			return union.BoolValue;
		}

		/// <summary>
		/// Returns true or false randomly
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool NextBool()
		{
			return NextBool(ref s_state);
		}

		/// <summary>
		/// Fills buffer slice with random numbers
		/// </summary>
		public static void NextBytes(byte[] buffer, int offset, int length)
		{
			NextBytes(ref s_state, new Span<byte>(buffer, offset, length));
		}

		public static void NextBytes(byte[] buffer)
		{
			NextBytes(buffer, 0, buffer.Length);
		}

		public static void NextBytes(Span<byte> buffer)
		{
			NextBytes(ref s_state, buffer);
		}

		/// <summary>
		/// Fill span with random bytes
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void NextBytes(ref ulong state, Span<byte> bytes)
		{
			unchecked
			{
				Span<ulong> ulongs = MemoryMarshal.Cast<byte, ulong>(bytes);

				var full = bytes.Length >> 3;
				for (int i = 0; i < full; i++)
				{
					var x = state;
					x ^= x >> 12;
					x ^= x << 25;
					x ^= x >> 27;
					state = x;
					ulongs[i] = x * c_star;
				}

				int offset = full << 3;
				switch (bytes.Length - offset)
				{
					case 0:
					default:
						return;

					case 1:
						bytes[offset] = (byte)NextUInt64(ref state);
						return;

					case 2:
						var r = NextUInt64(ref state);
						bytes[offset] = (byte)r;
						bytes[offset + 1] = (byte)(r >> 8);
						return;

					case 3:
						var r2 = NextUInt64(ref state);
						bytes[offset] = (byte)r2;
						bytes[offset + 1] = (byte)(r2 >> 8);
						bytes[offset + 2] = (byte)(r2 >> 16);
						return;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int Next(ref ulong state, int minValue, int maxValue)
		{
			CoreException.Assert(maxValue > minValue);
			unchecked
			{
				var x = state;
				x ^= x >> 12;
				x ^= x << 25;
				x ^= x >> 27;
				state = x;

				// lemire fastrange
				ulong rnd = (x * c_star) >> 32; // use upper bits
				ulong span = (ulong)((long)maxValue - (long)minValue);
				uint offset = (uint)((rnd * span) >> 32);
				var retval = (int)(minValue + offset);

				CoreException.Assert(retval >= minValue && retval < maxValue);

				return retval;
			}
		}

		/// <summary>
		/// Returns a random value larger or equal to minValue and less than maxValue
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int Next(int minValue, int maxValue)
		{
			return Next(ref s_state, minValue, maxValue);
		}

		/// <summary>
		/// Returns random value larger or equal to 0.0 and less than 1.0
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static double NextDouble(ref ulong state)
		{
			DoubleULongUnion union;
			union.DoubleValue = 0;
			// generate 52 random mantissa bits and an unbiased exponent of 0
			union.ULongValue = (NextUInt64(ref state) & 0xFFFFFFFFFFFFFUL) | 0x3FF0000000000000UL;
			double zeroToOne = union.DoubleValue - 1.0;
			CoreException.Assert(zeroToOne >= 0.0f && zeroToOne < 1.0);
			return zeroToOne;
		}

		/// <summary>
		/// Returns random value larger or equal to 0.0 and less than 1.0
		/// </summary>
		public static double NextDouble()
		{
			return NextDouble(ref s_state);
		}

		/// <summary>
		/// Returns random value larger or equal to minValue and less than maxValue
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static double NextDouble(ref ulong state, double minValue, double maxValue)
		{
			CoreException.Assert(maxValue > minValue);

			DoubleULongUnion union;
			union.DoubleValue = 0;
			union.ULongValue = (NextUInt64(ref state) & 0xFFFFFFFFFFFFFUL) | 0x3FF0000000000000UL;
			double zeroToOne = union.DoubleValue - 1.0;
			double retval = minValue + ((maxValue - minValue) * zeroToOne);
			CoreException.Assert(retval >= minValue && retval < maxValue);
			return retval;
		}

		/// <summary>
		/// Returns random value larger or equal to minValue and less than maxValue
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static double NextDouble(double minValue, double maxValue)
		{
			return NextDouble(ref s_state, minValue, maxValue);
		}

		/// <summary>
		/// Returns random value larger or equal to 0.0f and less than 1.0f
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static float NextFloat(ref ulong state)
		{
			SingleUIntUnion union;
			union.SingleValue = 0;
			// generate a float with 23 random mantissa bits and an (unbiased) exponent of 0
			union.UIntValue = (NextUInt32(ref state) & 0b01111111_11111111_11111111u) | 0x3F800000u;
			float zeroToOne = union.SingleValue - 1.0f;
			CoreException.Assert(zeroToOne >= 0.0f && zeroToOne < 1.0);
			return zeroToOne;
		}

		/// <summary>
		/// Returns random value larger or equal to 0.0f and less than 1.0f
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static float NextFloat()
		{
			return NextFloat(ref s_state);
		}

		/// <summary>
		/// Returns random value larger or equal to minValue and less than maxValue
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static float NextFloat(ref ulong state, float minValue, float maxValue)
		{
			return (float)NextDouble(ref state, minValue, maxValue);
		}

		/// <summary>
		/// Returns random value larger or equal to minValue and less than maxValue
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static float NextFloat(float minValue, float maxValue)
		{
			return (float)NextDouble(ref s_state, minValue, maxValue);
		}

		/// <summary>
		/// Returns random point on circle, unit length
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void NextUnitCircle(out float x, out float y)
		{
			NextUnitCircle(ref s_state, out x, out y);
		}

		/// <summary>
		/// Returns random point on circle, unit length
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void NextUnitCircle(ref ulong state, out float x, out float y)
		{
			var azimuth = NextFloat(0, MathF.PI * 2.0f);
			x = MathF.Cos(azimuth);
			y = MathF.Sin(azimuth);
		}

		/// <summary>
		/// Returns random point on sphere, unit length
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void NextUnitSphere(out float x, out float y, out float z)
		{
			NextUnitSphere(ref s_state, out x, out y, out z);
		}

		/// <summary>
		/// Returns random point on sphere, unit length
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static Vector3 NextUnitSphere()
		{
			Vector3 retval;
			NextUnitSphere(ref s_state, out retval.X, out retval.Y, out retval.Z);
			return retval;
		}

		/// <summary>
		/// Returns random point on sphere, unit length
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void NextUnitSphere(ref ulong state, out float x, out float y, out float z)
		{
			float dz = NextFloat(ref state) * 2.0f - 1.0f;
			float m = MathF.Sqrt(1.0f - dz * dz);
			float azimuth = ((NextFloat(ref state) * 2.0f - 1.0f) * 0.5f + 0.5f) * 2.0f * MathF.PI;
			x = MathF.Cos(azimuth) * m;
			y = MathF.Sin(azimuth) * m;
			z = dz;
		}

		/// <summary>
		/// Returns random point on sphere, unit length
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void NextUnitSphereDoublePrecision(ref ulong state, out double x, out double y, out double z)
		{
			double dz = NextDouble(ref state) * 2.0 - 1.0;
			double m = Math.Sqrt(1.0 - dz * dz);
			double azimuth = ((NextDouble(ref state) * 2.0 - 1.0) * 0.5 + 0.5) * 2.0 * Math.PI;
			x = Math.Cos(azimuth) * m;
			y = Math.Sin(azimuth) * m;
			z = dz;
		}

		/// <summary>
		/// Returns a random rotation around an axis
		/// </summary>
		public static Quaternion NextAxisRotation(in Vector3 axis)
		{
			return Quaternion.CreateFromAxisAngle(axis, PRNG.NextFloat(0, MathF.PI * 2.0f));
		}

		/// <summary>
		/// Returns a random rotation around a random axis
		/// </summary>
		public static Quaternion NextRotation()
		{
			Vector3 axis;
			NextUnitSphere(out axis.X, out axis.Y, out axis.Z);
			return Quaternion.CreateFromAxisAngle(axis, PRNG.NextFloat(0, MathF.PI * 2.0f));
		}

		/// <summary>
		/// Returns values from a rough bell shape skewed to have its peak at 'mode'  (min <= x < max)
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static float NextPseudoGaussian(float min, float max, float mode)
		{
			return NextPseudoGaussian(ref s_state, min, max, mode);
		}

		/// <summary>
		/// Returns values from a rough bell shape skewed to have its peak at 'mode'  (min <= x < max)
		/// </summary>
		public static float NextPseudoGaussian(ref ulong state, float min, float max, float mode)
		{
			float nrmValue;
			nrmValue = (NextFloat(ref state) + NextFloat(ref state) + NextFloat(ref state)) * 0.666666666f;
			if (nrmValue > 1.0f)
				nrmValue = 1.0f - (nrmValue - 1.0f);

			var modep = (mode - min) / (max - min);
			if (NextDouble() < modep)
			{
				// lower half
				var span = mode - min;
				return min + (span * nrmValue);
			}
			else
			{
				// upper half
				var span = max - mode;
				return mode + (span * (1.0f - nrmValue));
			}
		}

		/// <summary>
		/// Returns values from a rough bell shape skewed to have its peak at 'mode'  (min <= x < max)
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static double NextPseudoGaussian(double min, double max, double mode)
		{
			return NextPseudoGaussian(ref s_state, min, max, mode);
		}

		/// <summary>
		/// Returns values from a rough bell shape skewed to have its peak at 'mode'  (min <= x < max)
		/// </summary>
		public static double NextPseudoGaussian(ref ulong state, double min, double max, double mode)
		{
			double nrmValue;
			nrmValue = (NextDouble(ref state) + NextDouble(ref state) + NextDouble(ref state)) * 0.666666666f;
			if (nrmValue > 1.0)
				nrmValue = 1.0 - (nrmValue - 1.0);

			var modep = (mode - min) / (max - min);
			if (NextDouble() < modep)
			{
				// lower half
				var span = mode - min;
				return min + (span * nrmValue);
			}
			else
			{
				// upper half
				var span = max - mode;
				return mode + (span * (1.0 - nrmValue));
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void Shuffle<T>(Span<T> list)
		{
			Shuffle(list, ref s_state);
		}

		/// <summary>
		/// Randomly shuffle the elements (Fisher-Yates)
		/// </summary>
		public static void Shuffle<T>(in Span<T> list, ref ulong state)
		{
			for (int i = 0; i < list.Length - 1; i++)
			{
				int j = Next(i, list.Length);
				T tmp = list[i];
				list[i] = list[j];
				list[j] = tmp;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void Fill<T>(Span<T> span) where T : struct
		{
			var bytes = MemoryMarshal.AsBytes<T>(span);
			NextBytes(bytes);
		}
	}
}
